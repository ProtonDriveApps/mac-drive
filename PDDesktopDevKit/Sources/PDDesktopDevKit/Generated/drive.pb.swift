// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: drive.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum DevicePlatform: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case invalid // = 0
  case windows // = 1
  case macos // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .windows
    case 2: self = .macos
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .windows: return 1
    case .macos: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [DevicePlatform] = [
    .invalid,
    .windows,
    .macos,
  ]

}

public enum FileSampleType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case invalid // = 0
  case thumbnail // = 1
  case preview // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .thumbnail
    case 2: self = .preview
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .thumbnail: return 1
    case .preview: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [FileSampleType] = [
    .invalid,
    .thumbnail,
    .preview,
  ]

}

public enum MemberPermissions: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case invalid // = 0
  case write // = 2
  case read // = 4
  case admin // = 16
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 2: self = .write
    case 4: self = .read
    case 16: self = .admin
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .write: return 2
    case .read: return 4
    case .admin: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [MemberPermissions] = [
    .invalid,
    .write,
    .read,
    .admin,
  ]

}

public enum MemberState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case invalid // = 0
  case active // = 1
  case locked // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .active
    case 2: self = .locked
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .active: return 1
    case .locked: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [MemberState] = [
    .invalid,
    .active,
    .locked,
  ]

}

public enum ShareState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case invalid // = 0
  case active // = 1
  case deleted // = 2
  case restored // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .active
    case 2: self = .deleted
    case 3: self = .restored
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .active: return 1
    case .deleted: return 2
    case .restored: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [ShareState] = [
    .invalid,
    .active,
    .deleted,
    .restored,
  ]

}

public enum ShareType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case invalid // = 0
  case main // = 1
  case standard // = 2
  case device // = 3
  case photos // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .main
    case 2: self = .standard
    case 3: self = .device
    case 4: self = .photos
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .main: return 1
    case .standard: return 2
    case .device: return 3
    case .photos: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [ShareType] = [
    .invalid,
    .main,
    .standard,
    .device,
    .photos,
  ]

}

public enum VolumeEventType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// A file or folder was garbage collected or moved out of share view.
  case delete // = 0

  /// A file or folder was created or moved into a share view. For files, it is
  /// generated when the first revision is committed.
  case create // = 1

  /// File contents were updated.
  case update // = 2

  /// File or folder metadata was updated. Includes updates to name, parent link,
  /// shares, share URLs, and state (active, trashed, permanently deleted).
  case updateMetadata // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .delete
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .delete
    case 1: self = .create
    case 2: self = .update
    case 3: self = .updateMetadata
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .delete: return 0
    case .create: return 1
    case .update: return 2
    case .updateMetadata: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [VolumeEventType] = [
    .delete,
    .create,
    .update,
    .updateMetadata,
  ]

}

public enum VolumeState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0
  case active // = 1
  case deleted // = 2
  case locked // = 3
  case restored // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .active
    case 2: self = .deleted
    case 3: self = .locked
    case 4: self = .restored
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .active: return 1
    case .deleted: return 2
    case .locked: return 3
    case .restored: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [VolumeState] = [
    .none,
    .active,
    .deleted,
    .locked,
    .restored,
  ]

}

public enum NodeState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case draft // = 0
  case active // = 1
  case trashed // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .draft
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .draft
    case 1: self = .active
    case 2: self = .trashed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .draft: return 0
    case .active: return 1
    case .trashed: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [NodeState] = [
    .draft,
    .active,
    .trashed,
  ]

}

public enum RevisionState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case draft // = 0
  case active // = 1
  case superseded // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .draft
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .draft
    case 1: self = .active
    case 2: self = .superseded
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .draft: return 0
    case .active: return 1
    case .superseded: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [RevisionState] = [
    .draft,
    .active,
    .superseded,
  ]

}

public enum VerificationStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case ok // = 0
  case notSigned // = 1
  case noVerifier // = 2
  case failed // = 3
  case badContext // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .ok
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .notSigned
    case 2: self = .noVerifier
    case 3: self = .failed
    case 4: self = .badContext
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ok: return 0
    case .notSigned: return 1
    case .noVerifier: return 2
    case .failed: return 3
    case .badContext: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [VerificationStatus] = [
    .ok,
    .notSigned,
    .noVerifier,
    .failed,
    .badContext,
  ]

}

public enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case ok // = 0
  case notOk // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .ok
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .notOk
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ok: return 0
    case .notOk: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Status] = [
    .ok,
    .notOk,
  ]

}

public struct FileNode: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeIdentity: NodeIdentity {
    get {return _storage._nodeIdentity ?? NodeIdentity()}
    set {_uniqueStorage()._nodeIdentity = newValue}
  }
  /// Returns true if `nodeIdentity` has been explicitly set.
  public var hasNodeIdentity: Bool {return _storage._nodeIdentity != nil}
  /// Clears the value of `nodeIdentity`. Subsequent reads from it will return its default value.
  public mutating func clearNodeIdentity() {_uniqueStorage()._nodeIdentity = nil}

  public var parentID: LinkId {
    get {return _storage._parentID ?? LinkId()}
    set {_uniqueStorage()._parentID = newValue}
  }
  /// Returns true if `parentID` has been explicitly set.
  public var hasParentID: Bool {return _storage._parentID != nil}
  /// Clears the value of `parentID`. Subsequent reads from it will return its default value.
  public mutating func clearParentID() {_uniqueStorage()._parentID = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var nameHashDigest: Data {
    get {return _storage._nameHashDigest}
    set {_uniqueStorage()._nameHashDigest = newValue}
  }

  public var state: NodeState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  public var activeRevision: Revision {
    get {return _storage._activeRevision ?? Revision()}
    set {_uniqueStorage()._activeRevision = newValue}
  }
  /// Returns true if `activeRevision` has been explicitly set.
  public var hasActiveRevision: Bool {return _storage._activeRevision != nil}
  /// Clears the value of `activeRevision`. Subsequent reads from it will return its default value.
  public mutating func clearActiveRevision() {_uniqueStorage()._activeRevision = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct FolderNode: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeIdentity: NodeIdentity {
    get {return _nodeIdentity ?? NodeIdentity()}
    set {_nodeIdentity = newValue}
  }
  /// Returns true if `nodeIdentity` has been explicitly set.
  public var hasNodeIdentity: Bool {return self._nodeIdentity != nil}
  /// Clears the value of `nodeIdentity`. Subsequent reads from it will return its default value.
  public mutating func clearNodeIdentity() {self._nodeIdentity = nil}

  public var parentID: LinkId {
    get {return _parentID ?? LinkId()}
    set {_parentID = newValue}
  }
  /// Returns true if `parentID` has been explicitly set.
  public var hasParentID: Bool {return self._parentID != nil}
  /// Clears the value of `parentID`. Subsequent reads from it will return its default value.
  public mutating func clearParentID() {self._parentID = nil}

  public var name: String = String()

  public var nameHashDigest: Data = Data()

  public var state: NodeState = .draft

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodeIdentity: NodeIdentity? = nil
  fileprivate var _parentID: LinkId? = nil
}

public struct NodeIdentity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeID: LinkId {
    get {return _nodeID ?? LinkId()}
    set {_nodeID = newValue}
  }
  /// Returns true if `nodeID` has been explicitly set.
  public var hasNodeID: Bool {return self._nodeID != nil}
  /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
  public mutating func clearNodeID() {self._nodeID = nil}

  public var shareID: ShareId {
    get {return _shareID ?? ShareId()}
    set {_shareID = newValue}
  }
  /// Returns true if `shareID` has been explicitly set.
  public var hasShareID: Bool {return self._shareID != nil}
  /// Clears the value of `shareID`. Subsequent reads from it will return its default value.
  public mutating func clearShareID() {self._shareID = nil}

  public var volumeID: VolumeId {
    get {return _volumeID ?? VolumeId()}
    set {_volumeID = newValue}
  }
  /// Returns true if `volumeID` has been explicitly set.
  public var hasVolumeID: Bool {return self._volumeID != nil}
  /// Clears the value of `volumeID`. Subsequent reads from it will return its default value.
  public mutating func clearVolumeID() {self._volumeID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodeID: LinkId? = nil
  fileprivate var _shareID: ShareId? = nil
  fileprivate var _volumeID: VolumeId? = nil
}

public struct ShareMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shareID: ShareId {
    get {return _shareID ?? ShareId()}
    set {_shareID = newValue}
  }
  /// Returns true if `shareID` has been explicitly set.
  public var hasShareID: Bool {return self._shareID != nil}
  /// Clears the value of `shareID`. Subsequent reads from it will return its default value.
  public mutating func clearShareID() {self._shareID = nil}

  public var membershipAddressID: AddressId {
    get {return _membershipAddressID ?? AddressId()}
    set {_membershipAddressID = newValue}
  }
  /// Returns true if `membershipAddressID` has been explicitly set.
  public var hasMembershipAddressID: Bool {return self._membershipAddressID != nil}
  /// Clears the value of `membershipAddressID`. Subsequent reads from it will return its default value.
  public mutating func clearMembershipAddressID() {self._membershipAddressID = nil}

  public var membershipEmailAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _shareID: ShareId? = nil
  fileprivate var _membershipAddressID: AddressId? = nil
}

public struct Share: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shareID: ShareId {
    get {return _shareID ?? ShareId()}
    set {_shareID = newValue}
  }
  /// Returns true if `shareID` has been explicitly set.
  public var hasShareID: Bool {return self._shareID != nil}
  /// Clears the value of `shareID`. Subsequent reads from it will return its default value.
  public mutating func clearShareID() {self._shareID = nil}

  public var membershipAddressID: AddressId {
    get {return _membershipAddressID ?? AddressId()}
    set {_membershipAddressID = newValue}
  }
  /// Returns true if `membershipAddressID` has been explicitly set.
  public var hasMembershipAddressID: Bool {return self._membershipAddressID != nil}
  /// Clears the value of `membershipAddressID`. Subsequent reads from it will return its default value.
  public mutating func clearMembershipAddressID() {self._membershipAddressID = nil}

  public var membershipEmailAddress: String = String()

  public var volumeID: VolumeId {
    get {return _volumeID ?? VolumeId()}
    set {_volumeID = newValue}
  }
  /// Returns true if `volumeID` has been explicitly set.
  public var hasVolumeID: Bool {return self._volumeID != nil}
  /// Clears the value of `volumeID`. Subsequent reads from it will return its default value.
  public mutating func clearVolumeID() {self._volumeID = nil}

  public var rootNodeID: LinkId {
    get {return _rootNodeID ?? LinkId()}
    set {_rootNodeID = newValue}
  }
  /// Returns true if `rootNodeID` has been explicitly set.
  public var hasRootNodeID: Bool {return self._rootNodeID != nil}
  /// Clears the value of `rootNodeID`. Subsequent reads from it will return its default value.
  public mutating func clearRootNodeID() {self._rootNodeID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _shareID: ShareId? = nil
  fileprivate var _membershipAddressID: AddressId? = nil
  fileprivate var _volumeID: VolumeId? = nil
  fileprivate var _rootNodeID: LinkId? = nil
}

public struct RevisionMetadata: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var revisionID: RevisionId {
    get {return _revisionID ?? RevisionId()}
    set {_revisionID = newValue}
  }
  /// Returns true if `revisionID` has been explicitly set.
  public var hasRevisionID: Bool {return self._revisionID != nil}
  /// Clears the value of `revisionID`. Subsequent reads from it will return its default value.
  public mutating func clearRevisionID() {self._revisionID = nil}

  public var state: RevisionState = .draft

  public var manifestSignature: Data {
    get {return _manifestSignature ?? Data()}
    set {_manifestSignature = newValue}
  }
  /// Returns true if `manifestSignature` has been explicitly set.
  public var hasManifestSignature: Bool {return self._manifestSignature != nil}
  /// Clears the value of `manifestSignature`. Subsequent reads from it will return its default value.
  public mutating func clearManifestSignature() {self._manifestSignature = nil}

  public var signatureEmailAddress: String {
    get {return _signatureEmailAddress ?? String()}
    set {_signatureEmailAddress = newValue}
  }
  /// Returns true if `signatureEmailAddress` has been explicitly set.
  public var hasSignatureEmailAddress: Bool {return self._signatureEmailAddress != nil}
  /// Clears the value of `signatureEmailAddress`. Subsequent reads from it will return its default value.
  public mutating func clearSignatureEmailAddress() {self._signatureEmailAddress = nil}

  public var samplesSha256Digests: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _revisionID: RevisionId? = nil
  fileprivate var _manifestSignature: Data? = nil
  fileprivate var _signatureEmailAddress: String? = nil
}

public struct Revision: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var revisionID: RevisionId {
    get {return _revisionID ?? RevisionId()}
    set {_revisionID = newValue}
  }
  /// Returns true if `revisionID` has been explicitly set.
  public var hasRevisionID: Bool {return self._revisionID != nil}
  /// Clears the value of `revisionID`. Subsequent reads from it will return its default value.
  public mutating func clearRevisionID() {self._revisionID = nil}

  public var state: RevisionState = .draft

  public var manifestSignature: Data {
    get {return _manifestSignature ?? Data()}
    set {_manifestSignature = newValue}
  }
  /// Returns true if `manifestSignature` has been explicitly set.
  public var hasManifestSignature: Bool {return self._manifestSignature != nil}
  /// Clears the value of `manifestSignature`. Subsequent reads from it will return its default value.
  public mutating func clearManifestSignature() {self._manifestSignature = nil}

  public var signatureEmailAddress: String {
    get {return _signatureEmailAddress ?? String()}
    set {_signatureEmailAddress = newValue}
  }
  /// Returns true if `signatureEmailAddress` has been explicitly set.
  public var hasSignatureEmailAddress: Bool {return self._signatureEmailAddress != nil}
  /// Clears the value of `signatureEmailAddress`. Subsequent reads from it will return its default value.
  public mutating func clearSignatureEmailAddress() {self._signatureEmailAddress = nil}

  public var samplesSha256Digests: [Data] = []

  public var volumeID: VolumeId {
    get {return _volumeID ?? VolumeId()}
    set {_volumeID = newValue}
  }
  /// Returns true if `volumeID` has been explicitly set.
  public var hasVolumeID: Bool {return self._volumeID != nil}
  /// Clears the value of `volumeID`. Subsequent reads from it will return its default value.
  public mutating func clearVolumeID() {self._volumeID = nil}

  public var fileID: LinkId {
    get {return _fileID ?? LinkId()}
    set {_fileID = newValue}
  }
  /// Returns true if `fileID` has been explicitly set.
  public var hasFileID: Bool {return self._fileID != nil}
  /// Clears the value of `fileID`. Subsequent reads from it will return its default value.
  public mutating func clearFileID() {self._fileID = nil}

  public var size: Int64 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  public var quotaConsumption: Int64 = 0

  public var creationTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _revisionID: RevisionId? = nil
  fileprivate var _manifestSignature: Data? = nil
  fileprivate var _signatureEmailAddress: String? = nil
  fileprivate var _volumeID: VolumeId? = nil
  fileprivate var _fileID: LinkId? = nil
  fileprivate var _size: Int64? = nil
}

public struct ShareBasedRevisionIdentity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shareID: ShareId {
    get {return _shareID ?? ShareId()}
    set {_shareID = newValue}
  }
  /// Returns true if `shareID` has been explicitly set.
  public var hasShareID: Bool {return self._shareID != nil}
  /// Clears the value of `shareID`. Subsequent reads from it will return its default value.
  public mutating func clearShareID() {self._shareID = nil}

  public var nodeID: LinkId {
    get {return _nodeID ?? LinkId()}
    set {_nodeID = newValue}
  }
  /// Returns true if `nodeID` has been explicitly set.
  public var hasNodeID: Bool {return self._nodeID != nil}
  /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
  public mutating func clearNodeID() {self._nodeID = nil}

  public var revisionID: RevisionId {
    get {return _revisionID ?? RevisionId()}
    set {_revisionID = newValue}
  }
  /// Returns true if `revisionID` has been explicitly set.
  public var hasRevisionID: Bool {return self._revisionID != nil}
  /// Clears the value of `revisionID`. Subsequent reads from it will return its default value.
  public mutating func clearRevisionID() {self._revisionID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _shareID: ShareId? = nil
  fileprivate var _nodeID: LinkId? = nil
  fileprivate var _revisionID: RevisionId? = nil
}

public struct FileDownloadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fileIdentity: NodeIdentity {
    get {return _fileIdentity ?? NodeIdentity()}
    set {_fileIdentity = newValue}
  }
  /// Returns true if `fileIdentity` has been explicitly set.
  public var hasFileIdentity: Bool {return self._fileIdentity != nil}
  /// Clears the value of `fileIdentity`. Subsequent reads from it will return its default value.
  public mutating func clearFileIdentity() {self._fileIdentity = nil}

  public var revisionMetadata: RevisionMetadata {
    get {return _revisionMetadata ?? RevisionMetadata()}
    set {_revisionMetadata = newValue}
  }
  /// Returns true if `revisionMetadata` has been explicitly set.
  public var hasRevisionMetadata: Bool {return self._revisionMetadata != nil}
  /// Clears the value of `revisionMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearRevisionMetadata() {self._revisionMetadata = nil}

  public var targetFilePath: String = String()

  public var operationID: OperationIdentifier {
    get {return _operationID ?? OperationIdentifier()}
    set {_operationID = newValue}
  }
  /// Returns true if `operationID` has been explicitly set.
  public var hasOperationID: Bool {return self._operationID != nil}
  /// Clears the value of `operationID`. Subsequent reads from it will return its default value.
  public mutating func clearOperationID() {self._operationID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fileIdentity: NodeIdentity? = nil
  fileprivate var _revisionMetadata: RevisionMetadata? = nil
  fileprivate var _operationID: OperationIdentifier? = nil
}

/// Response: IntResponse
public struct FileUploaderCreationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fileSize: Int64 = 0

  public var numberOfSamples: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FileUploadRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shareMetadata: ShareMetadata {
    get {return _shareMetadata ?? ShareMetadata()}
    set {_shareMetadata = newValue}
  }
  /// Returns true if `shareMetadata` has been explicitly set.
  public var hasShareMetadata: Bool {return self._shareMetadata != nil}
  /// Clears the value of `shareMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearShareMetadata() {self._shareMetadata = nil}

  public var parentFolderIdentity: NodeIdentity {
    get {return _parentFolderIdentity ?? NodeIdentity()}
    set {_parentFolderIdentity = newValue}
  }
  /// Returns true if `parentFolderIdentity` has been explicitly set.
  public var hasParentFolderIdentity: Bool {return self._parentFolderIdentity != nil}
  /// Clears the value of `parentFolderIdentity`. Subsequent reads from it will return its default value.
  public mutating func clearParentFolderIdentity() {self._parentFolderIdentity = nil}

  public var name: String = String()

  public var mimeType: String = String()

  public var sourceFilePath: String = String()

  public var thumbnail: Data {
    get {return _thumbnail ?? Data()}
    set {_thumbnail = newValue}
  }
  /// Returns true if `thumbnail` has been explicitly set.
  public var hasThumbnail: Bool {return self._thumbnail != nil}
  /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
  public mutating func clearThumbnail() {self._thumbnail = nil}

  public var lastModificationDate: Int64 = 0

  public var operationID: OperationIdentifier {
    get {return _operationID ?? OperationIdentifier()}
    set {_operationID = newValue}
  }
  /// Returns true if `operationID` has been explicitly set.
  public var hasOperationID: Bool {return self._operationID != nil}
  /// Clears the value of `operationID`. Subsequent reads from it will return its default value.
  public mutating func clearOperationID() {self._operationID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _shareMetadata: ShareMetadata? = nil
  fileprivate var _parentFolderIdentity: NodeIdentity? = nil
  fileprivate var _thumbnail: Data? = nil
  fileprivate var _operationID: OperationIdentifier? = nil
}

public struct FileUploadResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var file: FileNode {
    get {return _file ?? FileNode()}
    set {_file = newValue}
  }
  /// Returns true if `file` has been explicitly set.
  public var hasFile: Bool {return self._file != nil}
  /// Clears the value of `file`. Subsequent reads from it will return its default value.
  public mutating func clearFile() {self._file = nil}

  public var revision: Revision {
    get {return _revision ?? Revision()}
    set {_revision = newValue}
  }
  /// Returns true if `revision` has been explicitly set.
  public var hasRevision: Bool {return self._revision != nil}
  /// Clears the value of `revision`. Subsequent reads from it will return its default value.
  public mutating func clearRevision() {self._revision = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _file: FileNode? = nil
  fileprivate var _revision: Revision? = nil
}

/// Response is a Revision
public struct RevisionUploadRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fileIdentity: NodeIdentity {
    get {return _storage._fileIdentity ?? NodeIdentity()}
    set {_uniqueStorage()._fileIdentity = newValue}
  }
  /// Returns true if `fileIdentity` has been explicitly set.
  public var hasFileIdentity: Bool {return _storage._fileIdentity != nil}
  /// Clears the value of `fileIdentity`. Subsequent reads from it will return its default value.
  public mutating func clearFileIdentity() {_uniqueStorage()._fileIdentity = nil}

  public var shareMetadata: ShareMetadata {
    get {return _storage._shareMetadata ?? ShareMetadata()}
    set {_uniqueStorage()._shareMetadata = newValue}
  }
  /// Returns true if `shareMetadata` has been explicitly set.
  public var hasShareMetadata: Bool {return _storage._shareMetadata != nil}
  /// Clears the value of `shareMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearShareMetadata() {_uniqueStorage()._shareMetadata = nil}

  public var revisionMetadata: RevisionMetadata {
    get {return _storage._revisionMetadata ?? RevisionMetadata()}
    set {_uniqueStorage()._revisionMetadata = newValue}
  }
  /// Returns true if `revisionMetadata` has been explicitly set.
  public var hasRevisionMetadata: Bool {return _storage._revisionMetadata != nil}
  /// Clears the value of `revisionMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearRevisionMetadata() {_uniqueStorage()._revisionMetadata = nil}

  public var thumbnail: Data {
    get {return _storage._thumbnail ?? Data()}
    set {_uniqueStorage()._thumbnail = newValue}
  }
  /// Returns true if `thumbnail` has been explicitly set.
  public var hasThumbnail: Bool {return _storage._thumbnail != nil}
  /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
  public mutating func clearThumbnail() {_uniqueStorage()._thumbnail = nil}

  public var lastModificationDate: Int64 {
    get {return _storage._lastModificationDate}
    set {_uniqueStorage()._lastModificationDate = newValue}
  }

  /// Do we need this?
  public var sourceFilePath: String {
    get {return _storage._sourceFilePath}
    set {_uniqueStorage()._sourceFilePath = newValue}
  }

  public var operationID: OperationIdentifier {
    get {return _storage._operationID ?? OperationIdentifier()}
    set {_uniqueStorage()._operationID = newValue}
  }
  /// Returns true if `operationID` has been explicitly set.
  public var hasOperationID: Bool {return _storage._operationID != nil}
  /// Clears the value of `operationID`. Subsequent reads from it will return its default value.
  public mutating func clearOperationID() {_uniqueStorage()._operationID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct ProgressUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bytesCompleted: Int64 = 0

  public var bytesInTotal: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtonDriveClientCreateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clientID: ClientId {
    get {return _clientID ?? ClientId()}
    set {_clientID = newValue}
  }
  /// Returns true if `clientID` has been explicitly set.
  public var hasClientID: Bool {return self._clientID != nil}
  /// Clears the value of `clientID`. Subsequent reads from it will return its default value.
  public mutating func clearClientID() {self._clientID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientID: ClientId? = nil
}

public struct VerificationStatusResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var verificationStatus: VerificationStatus = .ok

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct LinkId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct VolumeId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ShareId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct DeviceId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RevisionId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ClientId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ShareKeyRegistrationRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shareID: StringResponse {
    get {return _shareID ?? StringResponse()}
    set {_shareID = newValue}
  }
  /// Returns true if `shareID` has been explicitly set.
  public var hasShareID: Bool {return self._shareID != nil}
  /// Clears the value of `shareID`. Subsequent reads from it will return its default value.
  public mutating func clearShareID() {self._shareID = nil}

  public var shareKeyRawUnlockedData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _shareID: StringResponse? = nil
}

public struct NodeKeysRegistrationRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeIdentity: NodeIdentity {
    get {return _nodeIdentity ?? NodeIdentity()}
    set {_nodeIdentity = newValue}
  }
  /// Returns true if `nodeIdentity` has been explicitly set.
  public var hasNodeIdentity: Bool {return self._nodeIdentity != nil}
  /// Clears the value of `nodeIdentity`. Subsequent reads from it will return its default value.
  public mutating func clearNodeIdentity() {self._nodeIdentity = nil}

  public var nodeKeyRawUnlockedData: Data = Data()

  public var contentKeyRawUnlockedData: Data {
    get {return _contentKeyRawUnlockedData ?? Data()}
    set {_contentKeyRawUnlockedData = newValue}
  }
  /// Returns true if `contentKeyRawUnlockedData` has been explicitly set.
  public var hasContentKeyRawUnlockedData: Bool {return self._contentKeyRawUnlockedData != nil}
  /// Clears the value of `contentKeyRawUnlockedData`. Subsequent reads from it will return its default value.
  public mutating func clearContentKeyRawUnlockedData() {self._contentKeyRawUnlockedData = nil}

  public var hashKeyRawUnlockedData: Data {
    get {return _hashKeyRawUnlockedData ?? Data()}
    set {_hashKeyRawUnlockedData = newValue}
  }
  /// Returns true if `hashKeyRawUnlockedData` has been explicitly set.
  public var hasHashKeyRawUnlockedData: Bool {return self._hashKeyRawUnlockedData != nil}
  /// Clears the value of `hashKeyRawUnlockedData`. Subsequent reads from it will return its default value.
  public mutating func clearHashKeyRawUnlockedData() {self._hashKeyRawUnlockedData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodeIdentity: NodeIdentity? = nil
  fileprivate var _contentKeyRawUnlockedData: Data? = nil
  fileprivate var _hashKeyRawUnlockedData: Data? = nil
}

public struct NodeNameDecryptionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeIdentity: NodeIdentity {
    get {return _nodeIdentity ?? NodeIdentity()}
    set {_nodeIdentity = newValue}
  }
  /// Returns true if `nodeIdentity` has been explicitly set.
  public var hasNodeIdentity: Bool {return self._nodeIdentity != nil}
  /// Clears the value of `nodeIdentity`. Subsequent reads from it will return its default value.
  public mutating func clearNodeIdentity() {self._nodeIdentity = nil}

  public var armoredEncryptedName: String = String()

  public var signatureEmailAddress: String {
    get {return _signatureEmailAddress ?? String()}
    set {_signatureEmailAddress = newValue}
  }
  /// Returns true if `signatureEmailAddress` has been explicitly set.
  public var hasSignatureEmailAddress: Bool {return self._signatureEmailAddress != nil}
  /// Clears the value of `signatureEmailAddress`. Subsequent reads from it will return its default value.
  public mutating func clearSignatureEmailAddress() {self._signatureEmailAddress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodeIdentity: NodeIdentity? = nil
  fileprivate var _signatureEmailAddress: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension DevicePlatform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEVICE_PLATFORM_INVALID"),
    1: .same(proto: "DEVICE_PLATFORM_WINDOWS"),
    2: .same(proto: "DEVICE_PLATFORM_MACOS"),
  ]
}

extension FileSampleType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILE_SAMPLE_TYPE_INVALID"),
    1: .same(proto: "FILE_SAMPLE_TYPE_THUMBNAIL"),
    2: .same(proto: "FILE_SAMPLE_TYPE_PREVIEW"),
  ]
}

extension MemberPermissions: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMBER_PERMISSIONS_INVALID"),
    2: .same(proto: "MEMBER_PERMISSIONS_WRITE"),
    4: .same(proto: "MEMBER_PERMISSIONS_READ"),
    16: .same(proto: "MEMBER_PERMISSIONS_ADMIN"),
  ]
}

extension MemberState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMBER_STATE_INVALID"),
    1: .same(proto: "MEMBER_STATE_ACTIVE"),
    2: .same(proto: "MEMBER_STATE_LOCKED"),
  ]
}

extension ShareState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHARE_STATE_INVALID"),
    1: .same(proto: "SHARE_STATE_ACTIVE"),
    2: .same(proto: "SHARE_STATE_DELETED"),
    3: .same(proto: "SHARE_STATE_RESTORED"),
  ]
}

extension ShareType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHARE_TYPE_INVALID"),
    1: .same(proto: "SHARE_TYPE_MAIN"),
    2: .same(proto: "SHARE_TYPE_STANDARD"),
    3: .same(proto: "SHARE_TYPE_DEVICE"),
    4: .same(proto: "SHARE_TYPE_PHOTOS"),
  ]
}

extension VolumeEventType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOLUME_EVENT_TYPE_DELETE"),
    1: .same(proto: "VOLUME_EVENT_TYPE_CREATE"),
    2: .same(proto: "VOLUME_EVENT_TYPE_UPDATE"),
    3: .same(proto: "VOLUME_EVENT_TYPE_UPDATE_METADATA"),
  ]
}

extension VolumeState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOLUME_STATE_NONE"),
    1: .same(proto: "VOLUME_STATE_ACTIVE"),
    2: .same(proto: "VOLUME_STATE_DELETED"),
    3: .same(proto: "VOLUME_STATE_LOCKED"),
    4: .same(proto: "VOLUME_STATE_RESTORED"),
  ]
}

extension NodeState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NODE_STATE_DRAFT"),
    1: .same(proto: "NODE_STATE_ACTIVE"),
    2: .same(proto: "NODE_STATE_TRASHED"),
  ]
}

extension RevisionState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REVISION_STATE_DRAFT"),
    1: .same(proto: "REVISION_STATE_ACTIVE"),
    2: .same(proto: "REVISION_STATE_SUPERSEDED"),
  ]
}

extension VerificationStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERIFICATION_STATUS_OK"),
    1: .same(proto: "VERIFICATION_STATUS_NOT_SIGNED"),
    2: .same(proto: "VERIFICATION_STATUS_NO_VERIFIER"),
    3: .same(proto: "VERIFICATION_STATUS_FAILED"),
    4: .same(proto: "VERIFICATION_STATUS_BAD_CONTEXT"),
  ]
}

extension Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_OK"),
    1: .same(proto: "STATUS_NOT_OK"),
  ]
}

extension FileNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_identity"),
    2: .standard(proto: "parent_id"),
    3: .same(proto: "name"),
    4: .standard(proto: "name_hash_digest"),
    5: .same(proto: "state"),
    6: .standard(proto: "active_revision"),
  ]

  fileprivate class _StorageClass {
    var _nodeIdentity: NodeIdentity? = nil
    var _parentID: LinkId? = nil
    var _name: String = String()
    var _nameHashDigest: Data = Data()
    var _state: NodeState = .draft
    var _activeRevision: Revision? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _nodeIdentity = source._nodeIdentity
      _parentID = source._parentID
      _name = source._name
      _nameHashDigest = source._nameHashDigest
      _state = source._state
      _activeRevision = source._activeRevision
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._nodeIdentity) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._parentID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._nameHashDigest) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._activeRevision) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._nodeIdentity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._parentID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._nameHashDigest.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._nameHashDigest, fieldNumber: 4)
      }
      if _storage._state != .draft {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 5)
      }
      try { if let v = _storage._activeRevision {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileNode, rhs: FileNode) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._nodeIdentity != rhs_storage._nodeIdentity {return false}
        if _storage._parentID != rhs_storage._parentID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._nameHashDigest != rhs_storage._nameHashDigest {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._activeRevision != rhs_storage._activeRevision {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FolderNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FolderNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_identity"),
    2: .standard(proto: "parent_id"),
    3: .same(proto: "name"),
    4: .standard(proto: "name_hash_digest"),
    5: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeIdentity) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parentID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.nameHashDigest) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._parentID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.nameHashDigest.isEmpty {
      try visitor.visitSingularBytesField(value: self.nameHashDigest, fieldNumber: 4)
    }
    if self.state != .draft {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FolderNode, rhs: FolderNode) -> Bool {
    if lhs._nodeIdentity != rhs._nodeIdentity {return false}
    if lhs._parentID != rhs._parentID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.nameHashDigest != rhs.nameHashDigest {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NodeIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NodeIdentity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .standard(proto: "share_id"),
    3: .standard(proto: "volume_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._shareID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._volumeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._shareID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._volumeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NodeIdentity, rhs: NodeIdentity) -> Bool {
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._shareID != rhs._shareID {return false}
    if lhs._volumeID != rhs._volumeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShareMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShareMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "share_id"),
    2: .standard(proto: "membership_address_id"),
    3: .standard(proto: "membership_email_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._shareID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._membershipAddressID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.membershipEmailAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shareID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._membershipAddressID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.membershipEmailAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.membershipEmailAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShareMetadata, rhs: ShareMetadata) -> Bool {
    if lhs._shareID != rhs._shareID {return false}
    if lhs._membershipAddressID != rhs._membershipAddressID {return false}
    if lhs.membershipEmailAddress != rhs.membershipEmailAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Share: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Share"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "share_id"),
    2: .standard(proto: "membership_address_id"),
    3: .standard(proto: "membership_email_address"),
    4: .standard(proto: "volume_id"),
    5: .standard(proto: "root_node_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._shareID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._membershipAddressID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.membershipEmailAddress) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._volumeID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._rootNodeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shareID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._membershipAddressID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.membershipEmailAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.membershipEmailAddress, fieldNumber: 3)
    }
    try { if let v = self._volumeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._rootNodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Share, rhs: Share) -> Bool {
    if lhs._shareID != rhs._shareID {return false}
    if lhs._membershipAddressID != rhs._membershipAddressID {return false}
    if lhs.membershipEmailAddress != rhs.membershipEmailAddress {return false}
    if lhs._volumeID != rhs._volumeID {return false}
    if lhs._rootNodeID != rhs._rootNodeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RevisionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RevisionMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "revision_id"),
    2: .same(proto: "state"),
    3: .standard(proto: "manifest_signature"),
    4: .standard(proto: "signature_email_address"),
    5: .standard(proto: "samples_sha256_digests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._revisionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._manifestSignature) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._signatureEmailAddress) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.samplesSha256Digests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._revisionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.state != .draft {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try { if let v = self._manifestSignature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signatureEmailAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.samplesSha256Digests.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.samplesSha256Digests, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RevisionMetadata, rhs: RevisionMetadata) -> Bool {
    if lhs._revisionID != rhs._revisionID {return false}
    if lhs.state != rhs.state {return false}
    if lhs._manifestSignature != rhs._manifestSignature {return false}
    if lhs._signatureEmailAddress != rhs._signatureEmailAddress {return false}
    if lhs.samplesSha256Digests != rhs.samplesSha256Digests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Revision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Revision"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "revision_id"),
    2: .same(proto: "state"),
    3: .standard(proto: "manifest_signature"),
    4: .standard(proto: "signature_email_address"),
    5: .standard(proto: "samples_sha256_digests"),
    6: .standard(proto: "volume_id"),
    7: .standard(proto: "file_id"),
    8: .same(proto: "size"),
    9: .standard(proto: "quota_consumption"),
    10: .standard(proto: "creation_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._revisionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._manifestSignature) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._signatureEmailAddress) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.samplesSha256Digests) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._volumeID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._fileID) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self._size) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.quotaConsumption) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.creationTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._revisionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.state != .draft {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try { if let v = self._manifestSignature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._signatureEmailAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.samplesSha256Digests.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.samplesSha256Digests, fieldNumber: 5)
    }
    try { if let v = self._volumeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._fileID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 8)
    } }()
    if self.quotaConsumption != 0 {
      try visitor.visitSingularInt64Field(value: self.quotaConsumption, fieldNumber: 9)
    }
    if self.creationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.creationTime, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Revision, rhs: Revision) -> Bool {
    if lhs._revisionID != rhs._revisionID {return false}
    if lhs.state != rhs.state {return false}
    if lhs._manifestSignature != rhs._manifestSignature {return false}
    if lhs._signatureEmailAddress != rhs._signatureEmailAddress {return false}
    if lhs.samplesSha256Digests != rhs.samplesSha256Digests {return false}
    if lhs._volumeID != rhs._volumeID {return false}
    if lhs._fileID != rhs._fileID {return false}
    if lhs._size != rhs._size {return false}
    if lhs.quotaConsumption != rhs.quotaConsumption {return false}
    if lhs.creationTime != rhs.creationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShareBasedRevisionIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShareBasedRevisionIdentity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "share_id"),
    2: .standard(proto: "node_id"),
    3: .standard(proto: "revision_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._shareID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nodeID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._revisionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shareID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nodeID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._revisionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShareBasedRevisionIdentity, rhs: ShareBasedRevisionIdentity) -> Bool {
    if lhs._shareID != rhs._shareID {return false}
    if lhs._nodeID != rhs._nodeID {return false}
    if lhs._revisionID != rhs._revisionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileDownloadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileDownloadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_identity"),
    2: .standard(proto: "revision_metadata"),
    3: .standard(proto: "target_file_path"),
    4: .standard(proto: "operation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fileIdentity) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._revisionMetadata) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetFilePath) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._operationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fileIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._revisionMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.targetFilePath.isEmpty {
      try visitor.visitSingularStringField(value: self.targetFilePath, fieldNumber: 3)
    }
    try { if let v = self._operationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileDownloadRequest, rhs: FileDownloadRequest) -> Bool {
    if lhs._fileIdentity != rhs._fileIdentity {return false}
    if lhs._revisionMetadata != rhs._revisionMetadata {return false}
    if lhs.targetFilePath != rhs.targetFilePath {return false}
    if lhs._operationID != rhs._operationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileUploaderCreationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileUploaderCreationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_size"),
    2: .standard(proto: "number_of_samples"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.fileSize) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.numberOfSamples) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fileSize != 0 {
      try visitor.visitSingularInt64Field(value: self.fileSize, fieldNumber: 1)
    }
    if self.numberOfSamples != 0 {
      try visitor.visitSingularInt32Field(value: self.numberOfSamples, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileUploaderCreationRequest, rhs: FileUploaderCreationRequest) -> Bool {
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.numberOfSamples != rhs.numberOfSamples {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileUploadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "share_metadata"),
    2: .standard(proto: "parent_folder_identity"),
    3: .same(proto: "name"),
    4: .same(proto: "mimeType"),
    5: .standard(proto: "source_file_path"),
    6: .same(proto: "thumbnail"),
    7: .standard(proto: "last_modification_date"),
    8: .standard(proto: "operation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._shareMetadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parentFolderIdentity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sourceFilePath) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._thumbnail) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.lastModificationDate) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._operationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shareMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._parentFolderIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 4)
    }
    if !self.sourceFilePath.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceFilePath, fieldNumber: 5)
    }
    try { if let v = self._thumbnail {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    if self.lastModificationDate != 0 {
      try visitor.visitSingularInt64Field(value: self.lastModificationDate, fieldNumber: 7)
    }
    try { if let v = self._operationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileUploadRequest, rhs: FileUploadRequest) -> Bool {
    if lhs._shareMetadata != rhs._shareMetadata {return false}
    if lhs._parentFolderIdentity != rhs._parentFolderIdentity {return false}
    if lhs.name != rhs.name {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.sourceFilePath != rhs.sourceFilePath {return false}
    if lhs._thumbnail != rhs._thumbnail {return false}
    if lhs.lastModificationDate != rhs.lastModificationDate {return false}
    if lhs._operationID != rhs._operationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FileUploadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FileUploadResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "file"),
    2: .same(proto: "revision"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._file) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._revision) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._file {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._revision {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FileUploadResponse, rhs: FileUploadResponse) -> Bool {
    if lhs._file != rhs._file {return false}
    if lhs._revision != rhs._revision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RevisionUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RevisionUploadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_identity"),
    2: .standard(proto: "share_metadata"),
    3: .standard(proto: "revision_metadata"),
    4: .same(proto: "thumbnail"),
    5: .standard(proto: "last_modification_date"),
    6: .standard(proto: "source_file_path"),
    7: .standard(proto: "operation_id"),
  ]

  fileprivate class _StorageClass {
    var _fileIdentity: NodeIdentity? = nil
    var _shareMetadata: ShareMetadata? = nil
    var _revisionMetadata: RevisionMetadata? = nil
    var _thumbnail: Data? = nil
    var _lastModificationDate: Int64 = 0
    var _sourceFilePath: String = String()
    var _operationID: OperationIdentifier? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _fileIdentity = source._fileIdentity
      _shareMetadata = source._shareMetadata
      _revisionMetadata = source._revisionMetadata
      _thumbnail = source._thumbnail
      _lastModificationDate = source._lastModificationDate
      _sourceFilePath = source._sourceFilePath
      _operationID = source._operationID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._fileIdentity) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._shareMetadata) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._revisionMetadata) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._thumbnail) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._lastModificationDate) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._sourceFilePath) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._operationID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._fileIdentity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._shareMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._revisionMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._thumbnail {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      } }()
      if _storage._lastModificationDate != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastModificationDate, fieldNumber: 5)
      }
      if !_storage._sourceFilePath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sourceFilePath, fieldNumber: 6)
      }
      try { if let v = _storage._operationID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RevisionUploadRequest, rhs: RevisionUploadRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._fileIdentity != rhs_storage._fileIdentity {return false}
        if _storage._shareMetadata != rhs_storage._shareMetadata {return false}
        if _storage._revisionMetadata != rhs_storage._revisionMetadata {return false}
        if _storage._thumbnail != rhs_storage._thumbnail {return false}
        if _storage._lastModificationDate != rhs_storage._lastModificationDate {return false}
        if _storage._sourceFilePath != rhs_storage._sourceFilePath {return false}
        if _storage._operationID != rhs_storage._operationID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProgressUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProgressUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bytes_completed"),
    2: .standard(proto: "bytes_in_total"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.bytesCompleted) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.bytesInTotal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bytesCompleted != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesCompleted, fieldNumber: 1)
    }
    if self.bytesInTotal != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesInTotal, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProgressUpdate, rhs: ProgressUpdate) -> Bool {
    if lhs.bytesCompleted != rhs.bytesCompleted {return false}
    if lhs.bytesInTotal != rhs.bytesInTotal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtonDriveClientCreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtonDriveClientCreateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._clientID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._clientID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtonDriveClientCreateRequest, rhs: ProtonDriveClientCreateRequest) -> Bool {
    if lhs._clientID != rhs._clientID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VerificationStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "VerificationStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "verification_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.verificationStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.verificationStatus != .ok {
      try visitor.visitSingularEnumField(value: self.verificationStatus, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VerificationStatusResponse, rhs: VerificationStatusResponse) -> Bool {
    if lhs.verificationStatus != rhs.verificationStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LinkId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LinkId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LinkId, rhs: LinkId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VolumeId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "VolumeId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: VolumeId, rhs: VolumeId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShareId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShareId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShareId, rhs: ShareId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeviceId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: DeviceId, rhs: DeviceId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RevisionId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RevisionId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RevisionId, rhs: RevisionId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClientId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ClientId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ClientId, rhs: ClientId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ShareKeyRegistrationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ShareKeyRegistrationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "share_id"),
    2: .standard(proto: "share_key_raw_unlocked_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._shareID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.shareKeyRawUnlockedData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shareID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.shareKeyRawUnlockedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.shareKeyRawUnlockedData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ShareKeyRegistrationRequest, rhs: ShareKeyRegistrationRequest) -> Bool {
    if lhs._shareID != rhs._shareID {return false}
    if lhs.shareKeyRawUnlockedData != rhs.shareKeyRawUnlockedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NodeKeysRegistrationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NodeKeysRegistrationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_identity"),
    2: .standard(proto: "node_key_raw_unlocked_data"),
    3: .standard(proto: "content_key_raw_unlocked_data"),
    4: .standard(proto: "hash_key_raw_unlocked_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeIdentity) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nodeKeyRawUnlockedData) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._contentKeyRawUnlockedData) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._hashKeyRawUnlockedData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nodeKeyRawUnlockedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeKeyRawUnlockedData, fieldNumber: 2)
    }
    try { if let v = self._contentKeyRawUnlockedData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._hashKeyRawUnlockedData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NodeKeysRegistrationRequest, rhs: NodeKeysRegistrationRequest) -> Bool {
    if lhs._nodeIdentity != rhs._nodeIdentity {return false}
    if lhs.nodeKeyRawUnlockedData != rhs.nodeKeyRawUnlockedData {return false}
    if lhs._contentKeyRawUnlockedData != rhs._contentKeyRawUnlockedData {return false}
    if lhs._hashKeyRawUnlockedData != rhs._hashKeyRawUnlockedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NodeNameDecryptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NodeNameDecryptionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_identity"),
    2: .standard(proto: "armored_encrypted_name"),
    3: .standard(proto: "signature_email_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nodeIdentity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.armoredEncryptedName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._signatureEmailAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nodeIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.armoredEncryptedName.isEmpty {
      try visitor.visitSingularStringField(value: self.armoredEncryptedName, fieldNumber: 2)
    }
    try { if let v = self._signatureEmailAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NodeNameDecryptionRequest, rhs: NodeNameDecryptionRequest) -> Bool {
    if lhs._nodeIdentity != rhs._nodeIdentity {return false}
    if lhs.armoredEncryptedName != rhs.armoredEncryptedName {return false}
    if lhs._signatureEmailAddress != rhs._signatureEmailAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
