// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: account.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum AddressStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case disabled // = 0
  case enabled // = 1
  case deleting // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .disabled
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .disabled
    case 1: self = .enabled
    case 2: self = .deleting
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .disabled: return 0
    case .enabled: return 1
    case .deleting: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [AddressStatus] = [
    .disabled,
    .enabled,
    .deleting,
  ]

}

public enum AddressKeyFlags: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0
  case isAllowedForSignatureVerification // = 1
  case isAllowedForEncryption // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .isAllowedForSignatureVerification
    case 2: self = .isAllowedForEncryption
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .isAllowedForSignatureVerification: return 1
    case .isAllowedForEncryption: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [AddressKeyFlags] = [
    .none,
    .isAllowedForSignatureVerification,
    .isAllowedForEncryption,
  ]

}

public enum PasswordMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownPasswordMode // = 0
  case single // = 1
  case dual // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownPasswordMode
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownPasswordMode
    case 1: self = .single
    case 2: self = .dual
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownPasswordMode: return 0
    case .single: return 1
    case .dual: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [PasswordMode] = [
    .unknownPasswordMode,
    .single,
    .dual,
  ]

}

public enum DelinquentState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case paid // = 0
  case available // = 1
  case overdue // = 2
  case delinquent // = 3
  case notReceived // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .paid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .paid
    case 1: self = .available
    case 2: self = .overdue
    case 3: self = .delinquent
    case 4: self = .notReceived
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .paid: return 0
    case .available: return 1
    case .overdue: return 2
    case .delinquent: return 3
    case .notReceived: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [DelinquentState] = [
    .paid,
    .available,
    .overdue,
    .delinquent,
    .notReceived,
  ]

}

public enum UserType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case proton // = 1
  case managed // = 2
  case external // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .proton
    case 2: self = .managed
    case 3: self = .external
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .proton: return 1
    case .managed: return 2
    case .external: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [UserType] = [
    .unknown,
    .proton,
    .managed,
    .external,
  ]

}

public enum OperationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case invalid // = 0
  case download // = 1
  case fileUpload // = 2
  case revisionUpload // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .download
    case 2: self = .fileUpload
    case 3: self = .revisionUpload
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .download: return 1
    case .fileUpload: return 2
    case .revisionUpload: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OperationType] = [
    .invalid,
    .download,
    .fileUpload,
    .revisionUpload,
  ]

}

public enum RequestMethod: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case invalid // = 0
  case get // = 1
  case post // = 2
  case put // = 3
  case delete // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .get
    case 2: self = .post
    case 3: self = .put
    case 4: self = .delete
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .get: return 1
    case .post: return 2
    case .put: return 3
    case .delete: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [RequestMethod] = [
    .invalid,
    .get,
    .post,
    .put,
    .delete,
  ]

}

public enum ErrorDomain: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case undefined // = 0
  case successfulCancellation // = 1
  case api // = 2
  case network // = 3
  case transport // = 4
  case serialization // = 5
  case cryptography // = 6
  case dataIntegrity // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .undefined
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .successfulCancellation
    case 2: self = .api
    case 3: self = .network
    case 4: self = .transport
    case 5: self = .serialization
    case 6: self = .cryptography
    case 7: self = .dataIntegrity
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .successfulCancellation: return 1
    case .api: return 2
    case .network: return 3
    case .transport: return 4
    case .serialization: return 5
    case .cryptography: return 6
    case .dataIntegrity: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [ErrorDomain] = [
    .undefined,
    .successfulCancellation,
    .api,
    .network,
    .transport,
    .serialization,
    .cryptography,
    .dataIntegrity,
  ]

}

public struct UserKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyID: UserKeyId {
    get {return _keyID ?? UserKeyId()}
    set {_keyID = newValue}
  }
  /// Returns true if `keyID` has been explicitly set.
  public var hasKeyID: Bool {return self._keyID != nil}
  /// Clears the value of `keyID`. Subsequent reads from it will return its default value.
  public mutating func clearKeyID() {self._keyID = nil}

  public var keyData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keyID: UserKeyId? = nil
}

public struct ArmoredUserKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var keyID: UserKeyId {
    get {return _keyID ?? UserKeyId()}
    set {_keyID = newValue}
  }
  /// Returns true if `keyID` has been explicitly set.
  public var hasKeyID: Bool {return self._keyID != nil}
  /// Clears the value of `keyID`. Subsequent reads from it will return its default value.
  public mutating func clearKeyID() {self._keyID = nil}

  public var armoredKeyData: Data = Data()

  public var passphrase: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keyID: UserKeyId? = nil
}

public struct ProtonClientOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var appVersion: String = String()

  public var userAgent: String {
    get {return _userAgent ?? String()}
    set {_userAgent = newValue}
  }
  /// Returns true if `userAgent` has been explicitly set.
  public var hasUserAgent: Bool {return self._userAgent != nil}
  /// Clears the value of `userAgent`. Subsequent reads from it will return its default value.
  public mutating func clearUserAgent() {self._userAgent = nil}

  public var baseURL: String {
    get {return _baseURL ?? String()}
    set {_baseURL = newValue}
  }
  /// Returns true if `baseURL` has been explicitly set.
  public var hasBaseURL: Bool {return self._baseURL != nil}
  /// Clears the value of `baseURL`. Subsequent reads from it will return its default value.
  public mutating func clearBaseURL() {self._baseURL = nil}

  public var disableTlsPinning: Bool {
    get {return _disableTlsPinning ?? false}
    set {_disableTlsPinning = newValue}
  }
  /// Returns true if `disableTlsPinning` has been explicitly set.
  public var hasDisableTlsPinning: Bool {return self._disableTlsPinning != nil}
  /// Clears the value of `disableTlsPinning`. Subsequent reads from it will return its default value.
  public mutating func clearDisableTlsPinning() {self._disableTlsPinning = nil}

  public var ignoreSslCertificateErrors: Bool {
    get {return _ignoreSslCertificateErrors ?? false}
    set {_ignoreSslCertificateErrors = newValue}
  }
  /// Returns true if `ignoreSslCertificateErrors` has been explicitly set.
  public var hasIgnoreSslCertificateErrors: Bool {return self._ignoreSslCertificateErrors != nil}
  /// Clears the value of `ignoreSslCertificateErrors`. Subsequent reads from it will return its default value.
  public mutating func clearIgnoreSslCertificateErrors() {self._ignoreSslCertificateErrors = nil}

  public var loggerProviderHandle: Int64 {
    get {return _loggerProviderHandle ?? 0}
    set {_loggerProviderHandle = newValue}
  }
  /// Returns true if `loggerProviderHandle` has been explicitly set.
  public var hasLoggerProviderHandle: Bool {return self._loggerProviderHandle != nil}
  /// Clears the value of `loggerProviderHandle`. Subsequent reads from it will return its default value.
  public mutating func clearLoggerProviderHandle() {self._loggerProviderHandle = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userAgent: String? = nil
  fileprivate var _baseURL: String? = nil
  fileprivate var _disableTlsPinning: Bool? = nil
  fileprivate var _ignoreSslCertificateErrors: Bool? = nil
  fileprivate var _loggerProviderHandle: Int64? = nil
}

public struct SessionBeginRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var username: String = String()

  public var password: String = String()

  public var options: ProtonClientOptions {
    get {return _options ?? ProtonClientOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _options: ProtonClientOptions? = nil
}

public struct SessionResumeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: SessionId {
    get {return _sessionID ?? SessionId()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  public var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  public mutating func clearSessionID() {self._sessionID = nil}

  public var username: String = String()

  public var userID: UserId {
    get {return _userID ?? UserId()}
    set {_userID = newValue}
  }
  /// Returns true if `userID` has been explicitly set.
  public var hasUserID: Bool {return self._userID != nil}
  /// Clears the value of `userID`. Subsequent reads from it will return its default value.
  public mutating func clearUserID() {self._userID = nil}

  public var accessToken: String = String()

  public var refreshToken: String = String()

  public var scopes: [String] = []

  public var isWaitingForSecondFactorCode: Bool = false

  public var passwordMode: PasswordMode = .unknownPasswordMode

  public var options: ProtonClientOptions {
    get {return _options ?? ProtonClientOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sessionID: SessionId? = nil
  fileprivate var _userID: UserId? = nil
  fileprivate var _options: ProtonClientOptions? = nil
}

public struct SessionRenewRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: SessionId {
    get {return _sessionID ?? SessionId()}
    set {_sessionID = newValue}
  }
  /// Returns true if `sessionID` has been explicitly set.
  public var hasSessionID: Bool {return self._sessionID != nil}
  /// Clears the value of `sessionID`. Subsequent reads from it will return its default value.
  public mutating func clearSessionID() {self._sessionID = nil}

  public var accessToken: String = String()

  public var refreshToken: String = String()

  public var scopes: [String] = []

  public var isWaitingForSecondFactorCode: Bool = false

  public var passwordMode: PasswordMode = .unknownPasswordMode

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sessionID: SessionId? = nil
}

public struct SessionEndRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionHandle: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SessionTokens: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accessToken: String = String()

  public var refreshToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct LogEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var level: Int32 = 0

  public var message: String = String()

  public var categoryName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OperationIdentifier: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: OperationType = .invalid

  public var identifier: String = String()

  public var timestamp: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct RequestResponseBodyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var operationID: OperationIdentifier {
    get {return _operationID ?? OperationIdentifier()}
    set {_operationID = newValue}
  }
  /// Returns true if `operationID` has been explicitly set.
  public var hasOperationID: Bool {return self._operationID != nil}
  /// Clears the value of `operationID`. Subsequent reads from it will return its default value.
  public mutating func clearOperationID() {self._operationID = nil}

  public var method: RequestMethod = .invalid

  public var url: String = String()

  public var requestBody: String = String()

  public var responseBody: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _operationID: OperationIdentifier? = nil
}

public struct Error: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var domain: ErrorDomain {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  public var primaryCode: Int64 {
    get {return _storage._primaryCode ?? 0}
    set {_uniqueStorage()._primaryCode = newValue}
  }
  /// Returns true if `primaryCode` has been explicitly set.
  public var hasPrimaryCode: Bool {return _storage._primaryCode != nil}
  /// Clears the value of `primaryCode`. Subsequent reads from it will return its default value.
  public mutating func clearPrimaryCode() {_uniqueStorage()._primaryCode = nil}

  public var secondaryCode: Int64 {
    get {return _storage._secondaryCode ?? 0}
    set {_uniqueStorage()._secondaryCode = newValue}
  }
  /// Returns true if `secondaryCode` has been explicitly set.
  public var hasSecondaryCode: Bool {return _storage._secondaryCode != nil}
  /// Clears the value of `secondaryCode`. Subsequent reads from it will return its default value.
  public mutating func clearSecondaryCode() {_uniqueStorage()._secondaryCode = nil}

  public var context: String {
    get {return _storage._context ?? String()}
    set {_uniqueStorage()._context = newValue}
  }
  /// Returns true if `context` has been explicitly set.
  public var hasContext: Bool {return _storage._context != nil}
  /// Clears the value of `context`. Subsequent reads from it will return its default value.
  public mutating func clearContext() {_uniqueStorage()._context = nil}

  public var innerError: Error {
    get {return _storage._innerError ?? Error()}
    set {_uniqueStorage()._innerError = newValue}
  }
  /// Returns true if `innerError` has been explicitly set.
  public var hasInnerError: Bool {return _storage._innerError != nil}
  /// Clears the value of `innerError`. Subsequent reads from it will return its default value.
  public mutating func clearInnerError() {_uniqueStorage()._innerError = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct StringResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct IntResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Empty: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SessionId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UserId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UserKeyId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AddressId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AddressKeyId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct AddressKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var addressID: AddressId {
    get {return _addressID ?? AddressId()}
    set {_addressID = newValue}
  }
  /// Returns true if `addressID` has been explicitly set.
  public var hasAddressID: Bool {return self._addressID != nil}
  /// Clears the value of `addressID`. Subsequent reads from it will return its default value.
  public mutating func clearAddressID() {self._addressID = nil}

  public var addressKeyID: AddressKeyId {
    get {return _addressKeyID ?? AddressKeyId()}
    set {_addressKeyID = newValue}
  }
  /// Returns true if `addressKeyID` has been explicitly set.
  public var hasAddressKeyID: Bool {return self._addressKeyID != nil}
  /// Clears the value of `addressKeyID`. Subsequent reads from it will return its default value.
  public mutating func clearAddressKeyID() {self._addressKeyID = nil}

  public var isAllowedForEncryption: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _addressID: AddressId? = nil
  fileprivate var _addressKeyID: AddressKeyId? = nil
}

public struct AddressKeyWithData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var addressKeyID: AddressKeyId {
    get {return _addressKeyID ?? AddressKeyId()}
    set {_addressKeyID = newValue}
  }
  /// Returns true if `addressKeyID` has been explicitly set.
  public var hasAddressKeyID: Bool {return self._addressKeyID != nil}
  /// Clears the value of `addressKeyID`. Subsequent reads from it will return its default value.
  public mutating func clearAddressKeyID() {self._addressKeyID = nil}

  public var isPrimary: Bool = false

  public var isAllowedForEncryption: Bool = false

  public var rawUnlockedData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _addressKeyID: AddressKeyId? = nil
}

public struct AddressKeyRegistrationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var addressID: AddressId {
    get {return _addressID ?? AddressId()}
    set {_addressID = newValue}
  }
  /// Returns true if `addressID` has been explicitly set.
  public var hasAddressID: Bool {return self._addressID != nil}
  /// Clears the value of `addressID`. Subsequent reads from it will return its default value.
  public mutating func clearAddressID() {self._addressID = nil}

  public var keys: [AddressKeyWithData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _addressID: AddressId? = nil
}

public struct KeyCacheMissMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var holderID: String = String()

  public var holderName: String = String()

  public var contextID: String {
    get {return _contextID ?? String()}
    set {_contextID = newValue}
  }
  /// Returns true if `contextID` has been explicitly set.
  public var hasContextID: Bool {return self._contextID != nil}
  /// Clears the value of `contextID`. Subsequent reads from it will return its default value.
  public mutating func clearContextID() {self._contextID = nil}

  public var contextName: String {
    get {return _contextName ?? String()}
    set {_contextName = newValue}
  }
  /// Returns true if `contextName` has been explicitly set.
  public var hasContextName: Bool {return self._contextName != nil}
  /// Clears the value of `contextName`. Subsequent reads from it will return its default value.
  public mutating func clearContextName() {self._contextName = nil}

  public var valueName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _contextID: String? = nil
  fileprivate var _contextName: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension AddressStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADDRESS_STATUS_DISABLED"),
    1: .same(proto: "ADDRESS_STATUS_ENABLED"),
    2: .same(proto: "ADDRESS_STATUS_DELETING"),
  ]
}

extension AddressKeyFlags: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADDRESS_KEY_FLAGS_NONE"),
    1: .same(proto: "ADDRESS_KEY_FLAGS_IS_ALLOWED_FOR_SIGNATURE_VERIFICATION"),
    2: .same(proto: "ADDRESS_KEY_FLAGS_IS_ALLOWED_FOR_ENCRYPTION"),
  ]
}

extension PasswordMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PASSWORD_MODE_UNKNOWN_PASSWORD_MODE"),
    1: .same(proto: "PASSWORD_MODE_SINGLE"),
    2: .same(proto: "PASSWORD_MODE_DUAL"),
  ]
}

extension DelinquentState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DELINQUENT_STATE_PAID"),
    1: .same(proto: "DELINQUENT_STATE_AVAILABLE"),
    2: .same(proto: "DELINQUENT_STATE_OVERDUE"),
    3: .same(proto: "DELINQUENT_STATE_DELINQUENT"),
    4: .same(proto: "DELINQUENT_STATE_NOT_RECEIVED"),
  ]
}

extension UserType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER_TYPE_UNKNOWN"),
    1: .same(proto: "USER_TYPE_PROTON"),
    2: .same(proto: "USER_TYPE_MANAGED"),
    3: .same(proto: "USER_TYPE_EXTERNAL"),
  ]
}

extension OperationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATION_TYPE_INVALID"),
    1: .same(proto: "OPERATION_TYPE_DOWNLOAD"),
    2: .same(proto: "OPERATION_TYPE_FILE_UPLOAD"),
    3: .same(proto: "OPERATION_TYPE_REVISION_UPLOAD"),
  ]
}

extension RequestMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST_METHOD_INVALID"),
    1: .same(proto: "REQUEST_METHOD_GET"),
    2: .same(proto: "REQUEST_METHOD_POST"),
    3: .same(proto: "REQUEST_METHOD_PUT"),
    4: .same(proto: "REQUEST_METHOD_DELETE"),
  ]
}

extension ErrorDomain: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Undefined"),
    1: .same(proto: "SuccessfulCancellation"),
    2: .same(proto: "Api"),
    3: .same(proto: "Network"),
    4: .same(proto: "Transport"),
    5: .same(proto: "Serialization"),
    6: .same(proto: "Cryptography"),
    7: .same(proto: "DataIntegrity"),
  ]
}

extension UserKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_id"),
    2: .standard(proto: "key_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.keyData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.keyData.isEmpty {
      try visitor.visitSingularBytesField(value: self.keyData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserKey, rhs: UserKey) -> Bool {
    if lhs._keyID != rhs._keyID {return false}
    if lhs.keyData != rhs.keyData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ArmoredUserKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ArmoredUserKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_id"),
    2: .standard(proto: "armored_key_data"),
    3: .same(proto: "passphrase"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keyID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.armoredKeyData) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.passphrase) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._keyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.armoredKeyData.isEmpty {
      try visitor.visitSingularBytesField(value: self.armoredKeyData, fieldNumber: 2)
    }
    if !self.passphrase.isEmpty {
      try visitor.visitSingularStringField(value: self.passphrase, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ArmoredUserKey, rhs: ArmoredUserKey) -> Bool {
    if lhs._keyID != rhs._keyID {return false}
    if lhs.armoredKeyData != rhs.armoredKeyData {return false}
    if lhs.passphrase != rhs.passphrase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtonClientOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ProtonClientOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_version"),
    2: .standard(proto: "user_agent"),
    3: .standard(proto: "base_url"),
    4: .standard(proto: "disable_tls_pinning"),
    5: .standard(proto: "ignore_ssl_certificate_errors"),
    6: .standard(proto: "logger_provider_handle"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._userAgent) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._baseURL) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._disableTlsPinning) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._ignoreSslCertificateErrors) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self._loggerProviderHandle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 1)
    }
    try { if let v = self._userAgent {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._baseURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._disableTlsPinning {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._ignoreSslCertificateErrors {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._loggerProviderHandle {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ProtonClientOptions, rhs: ProtonClientOptions) -> Bool {
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs._userAgent != rhs._userAgent {return false}
    if lhs._baseURL != rhs._baseURL {return false}
    if lhs._disableTlsPinning != rhs._disableTlsPinning {return false}
    if lhs._ignoreSslCertificateErrors != rhs._ignoreSslCertificateErrors {return false}
    if lhs._loggerProviderHandle != rhs._loggerProviderHandle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionBeginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SessionBeginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
    3: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SessionBeginRequest, rhs: SessionBeginRequest) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionResumeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SessionResumeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .same(proto: "username"),
    3: .standard(proto: "user_id"),
    4: .standard(proto: "access_token"),
    5: .standard(proto: "refresh_token"),
    6: .same(proto: "scopes"),
    7: .standard(proto: "is_waiting_for_second_factor_code"),
    8: .standard(proto: "password_mode"),
    9: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sessionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._userID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.accessToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.scopes) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isWaitingForSecondFactorCode) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.passwordMode) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    try { if let v = self._userID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 4)
    }
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 5)
    }
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 6)
    }
    if self.isWaitingForSecondFactorCode != false {
      try visitor.visitSingularBoolField(value: self.isWaitingForSecondFactorCode, fieldNumber: 7)
    }
    if self.passwordMode != .unknownPasswordMode {
      try visitor.visitSingularEnumField(value: self.passwordMode, fieldNumber: 8)
    }
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SessionResumeRequest, rhs: SessionResumeRequest) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs.username != rhs.username {return false}
    if lhs._userID != rhs._userID {return false}
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.isWaitingForSecondFactorCode != rhs.isWaitingForSecondFactorCode {return false}
    if lhs.passwordMode != rhs.passwordMode {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionRenewRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SessionRenewRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "session_id"),
    3: .standard(proto: "access_token"),
    4: .standard(proto: "refresh_token"),
    5: .same(proto: "scopes"),
    6: .standard(proto: "is_waiting_for_second_factor_code"),
    7: .standard(proto: "password_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sessionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.accessToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.scopes) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isWaitingForSecondFactorCode) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.passwordMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sessionID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 3)
    }
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 4)
    }
    if !self.scopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.scopes, fieldNumber: 5)
    }
    if self.isWaitingForSecondFactorCode != false {
      try visitor.visitSingularBoolField(value: self.isWaitingForSecondFactorCode, fieldNumber: 6)
    }
    if self.passwordMode != .unknownPasswordMode {
      try visitor.visitSingularEnumField(value: self.passwordMode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SessionRenewRequest, rhs: SessionRenewRequest) -> Bool {
    if lhs._sessionID != rhs._sessionID {return false}
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs.scopes != rhs.scopes {return false}
    if lhs.isWaitingForSecondFactorCode != rhs.isWaitingForSecondFactorCode {return false}
    if lhs.passwordMode != rhs.passwordMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionEndRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SessionEndRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_handle"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.sessionHandle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sessionHandle != 0 {
      try visitor.visitSingularInt64Field(value: self.sessionHandle, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SessionEndRequest, rhs: SessionEndRequest) -> Bool {
    if lhs.sessionHandle != rhs.sessionHandle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionTokens: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SessionTokens"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
    2: .standard(proto: "refresh_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 1)
    }
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SessionTokens, rhs: SessionTokens) -> Bool {
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LogEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LogEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .same(proto: "message"),
    3: .standard(proto: "category_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.categoryName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.categoryName.isEmpty {
      try visitor.visitSingularStringField(value: self.categoryName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: LogEvent, rhs: LogEvent) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs.message != rhs.message {return false}
    if lhs.categoryName != rhs.categoryName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OperationIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "OperationIdentifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "identifier"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .invalid {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 2)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OperationIdentifier, rhs: OperationIdentifier) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.identifier != rhs.identifier {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RequestResponseBodyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RequestResponseBodyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operationId"),
    2: .same(proto: "method"),
    3: .same(proto: "url"),
    4: .same(proto: "requestBody"),
    5: .same(proto: "responseBody"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._operationID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.requestBody) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.responseBody) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._operationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.method != .invalid {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    if !self.requestBody.isEmpty {
      try visitor.visitSingularStringField(value: self.requestBody, fieldNumber: 4)
    }
    if !self.responseBody.isEmpty {
      try visitor.visitSingularStringField(value: self.responseBody, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: RequestResponseBodyResponse, rhs: RequestResponseBodyResponse) -> Bool {
    if lhs._operationID != rhs._operationID {return false}
    if lhs.method != rhs.method {return false}
    if lhs.url != rhs.url {return false}
    if lhs.requestBody != rhs.requestBody {return false}
    if lhs.responseBody != rhs.responseBody {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "message"),
    3: .same(proto: "domain"),
    4: .standard(proto: "primary_code"),
    5: .standard(proto: "secondary_code"),
    6: .same(proto: "context"),
    7: .standard(proto: "inner_error"),
  ]

  fileprivate class _StorageClass {
    var _type: String = String()
    var _message: String = String()
    var _domain: ErrorDomain = .undefined
    var _primaryCode: Int64? = nil
    var _secondaryCode: Int64? = nil
    var _context: String? = nil
    var _innerError: Error? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _message = source._message
      _domain = source._domain
      _primaryCode = source._primaryCode
      _secondaryCode = source._secondaryCode
      _context = source._context
      _innerError = source._innerError
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._domain) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._primaryCode) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._secondaryCode) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._context) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._innerError) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 2)
      }
      if _storage._domain != .undefined {
        try visitor.visitSingularEnumField(value: _storage._domain, fieldNumber: 3)
      }
      try { if let v = _storage._primaryCode {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._secondaryCode {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._context {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._innerError {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Error, rhs: Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._primaryCode != rhs_storage._primaryCode {return false}
        if _storage._secondaryCode != rhs_storage._secondaryCode {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._innerError != rhs_storage._innerError {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StringResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "StringResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StringResponse, rhs: StringResponse) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension IntResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "IntResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: IntResponse, rhs: IntResponse) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Empty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Empty"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Empty, rhs: Empty) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SessionId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SessionId, rhs: SessionId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserId, rhs: UserId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserKeyId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserKeyId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserKeyId, rhs: UserKeyId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddressId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AddressId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AddressId, rhs: AddressId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddressKeyId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AddressKeyId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AddressKeyId, rhs: AddressKeyId) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddressKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AddressKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "address_id"),
    2: .standard(proto: "address_key_id"),
    3: .standard(proto: "is_allowed_for_encryption"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._addressID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._addressKeyID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isAllowedForEncryption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._addressID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._addressKeyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isAllowedForEncryption != false {
      try visitor.visitSingularBoolField(value: self.isAllowedForEncryption, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AddressKey, rhs: AddressKey) -> Bool {
    if lhs._addressID != rhs._addressID {return false}
    if lhs._addressKeyID != rhs._addressKeyID {return false}
    if lhs.isAllowedForEncryption != rhs.isAllowedForEncryption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddressKeyWithData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AddressKeyWithData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "address_key_id"),
    2: .standard(proto: "is_primary"),
    3: .standard(proto: "is_allowed_for_encryption"),
    4: .standard(proto: "raw_unlocked_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._addressKeyID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isPrimary) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isAllowedForEncryption) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.rawUnlockedData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._addressKeyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.isPrimary != false {
      try visitor.visitSingularBoolField(value: self.isPrimary, fieldNumber: 2)
    }
    if self.isAllowedForEncryption != false {
      try visitor.visitSingularBoolField(value: self.isAllowedForEncryption, fieldNumber: 3)
    }
    if !self.rawUnlockedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawUnlockedData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AddressKeyWithData, rhs: AddressKeyWithData) -> Bool {
    if lhs._addressKeyID != rhs._addressKeyID {return false}
    if lhs.isPrimary != rhs.isPrimary {return false}
    if lhs.isAllowedForEncryption != rhs.isAllowedForEncryption {return false}
    if lhs.rawUnlockedData != rhs.rawUnlockedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AddressKeyRegistrationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AddressKeyRegistrationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "address_id"),
    2: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._addressID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._addressID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: AddressKeyRegistrationRequest, rhs: AddressKeyRegistrationRequest) -> Bool {
    if lhs._addressID != rhs._addressID {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension KeyCacheMissMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "KeyCacheMissMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "holder_id"),
    2: .standard(proto: "holder_name"),
    3: .standard(proto: "context_id"),
    4: .standard(proto: "context_name"),
    5: .standard(proto: "value_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.holderID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.holderName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._contextID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._contextName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.valueName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.holderID.isEmpty {
      try visitor.visitSingularStringField(value: self.holderID, fieldNumber: 1)
    }
    if !self.holderName.isEmpty {
      try visitor.visitSingularStringField(value: self.holderName, fieldNumber: 2)
    }
    try { if let v = self._contextID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._contextName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.valueName.isEmpty {
      try visitor.visitSingularStringField(value: self.valueName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: KeyCacheMissMessage, rhs: KeyCacheMissMessage) -> Bool {
    if lhs.holderID != rhs.holderID {return false}
    if lhs.holderName != rhs.holderName {return false}
    if lhs._contextID != rhs._contextID {return false}
    if lhs._contextName != rhs._contextName {return false}
    if lhs.valueName != rhs.valueName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
