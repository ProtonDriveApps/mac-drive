// Copyright (c) 2024 Proton AG
//
// This file is part of Proton Drive.
//
// Proton Drive is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Proton Drive is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Proton Drive. If not, see https://www.gnu.org/licenses/.

import CoreData
import PDClient

public protocol NewProtonFilePayloadFactoryProtocol {
    func makePayload(name: String, parentIdentifier: NodeIdentifier) throws -> NewProtonFilePayload
}

public final class NewProtonFilePayloadFactory: NewProtonFilePayloadFactoryProtocol {
    private let signersKitFactory: SignersKitFactoryProtocol
    private let managedObjectContext: NSManagedObjectContext
    private let storageManager: StorageManager
    private let encryptionResource: EncryptionResource
    private let fileType: ProtonFileType

    public init(signersKitFactory: SignersKitFactoryProtocol, managedObjectContext: NSManagedObjectContext, storageManager: StorageManager, encryptionResource: EncryptionResource, fileType: ProtonFileType) {
        self.signersKitFactory = signersKitFactory
        self.managedObjectContext = managedObjectContext
        self.storageManager = storageManager
        self.encryptionResource = encryptionResource
        self.fileType = fileType
    }

    public func makePayload(name: String, parentIdentifier: NodeIdentifier) throws -> NewProtonFilePayload {
        let (parentFolder, signersKit) = try managedObjectContext.performAndWait {
            let folder: Folder = try storageManager.fetchExisting(id: parentIdentifier, moc: managedObjectContext)
#if os(macOS)
            let signersKit = try signersKitFactory.make(forSigner: .main)
#else
            let addressID = try folder.getContextShareAddressID()
            let signersKit = try self.signersKitFactory.make(forAddressID: addressID)
#endif
            return (try folder.encrypting(), signersKit)
        }

        let addressPrivateKey = signersKit.addressKey.privateKey
        let addressPassphrase = signersKit.addressPassphrase

        do {
            // The name validation is failing for some users. Since the name should be generated by ourselves, we shouldn't need this.
            // But we need to find out why the auto-generated name validation fails.
            // Remove this after monitoring the issues
            _ = try name.validateNodeName(validator: NameValidations.iosName)
        } catch {
            Log
                .error(
                    "Validating NodeName failed",
                    error: error,
                    domain: .protonDocs,
                    context: LogContext("Input name: " + name)
                )
        }

        let encryptedName = try encryptionResource.encryptAndSign(
            name,
            key: parentFolder.nodeKey,
            addressPassphrase: addressPassphrase,
            addressPrivateKey: addressPrivateKey
        )
        let nameHash = try encryptionResource.makeHmac(string: name, hashKey: parentFolder.hashKey)
        let nodeKeyPack = try encryptionResource.generateNodeKeys(
            addressPassphrase: addressPassphrase,
            addressPrivateKey: addressPrivateKey,
            parentKey: parentFolder.nodeKey
        )
        let contentKeyPacket = try encryptionResource.generateContentKeys(nodeKey: nodeKeyPack.key, nodePassphrase: nodeKeyPack.passphraseRaw)
        let manifestSignature = try encryptionResource.sign(
            data: Data(), // intentionally empty, proton document doesn't have content
            addressKey: addressPrivateKey,
            addressPassphrase: addressPassphrase
        )

        return NewProtonFilePayload(
            name: encryptedName,
            hash: nameHash,
            parentLinkID: parentFolder.id,
            nodeKey: nodeKeyPack.key,
            nodePassphrase: nodeKeyPack.passphrase,
            nodePassphraseSignature: nodeKeyPack.signature,
            signatureAddress: signersKit.address.email,
            contentKeyPacket: contentKeyPacket.contentKeyPacketBase64,
            contentKeyPacketSignature: contentKeyPacket.contentKeyPacketSignature,
            manifestSignature: manifestSignature,
            documentType: getDocumentType()
        )
    }

    private func getDocumentType() -> NewProtonFilePayload.DocumentType {
        switch fileType {
        case .doc:
            return .document
        case .sheet:
            return .sheet
        }
    }
}
